{"version":3,"sources":["../../src/extractors/base.ts","../../src/extractors/vue-extractor.ts","../../src/extractors/js-extractor.ts","../../src/extractors/index.ts"],"sourcesContent":["/**\r\n * Base Extractor Class\r\n * All extractors should extend this class\r\n */\r\n\r\nexport interface ExtractionResult {\r\n  text: string\r\n  line: number\r\n  column: number\r\n  type?: 'template' | 'script' | 'style'\r\n  context?: string\r\n}\r\n\r\nexport interface ExtractorOptions {\r\n  include?: string[]\r\n  exclude?: string[]\r\n  useContext?: boolean\r\n  maxLength?: number\r\n  allowMixed?: boolean\r\n  allowPunctuation?: boolean\r\n}\r\n\r\nexport abstract class BaseExtractor {\r\n  protected options: ExtractorOptions\r\n\r\n  constructor(options: ExtractorOptions = {}) {\r\n    this.options = {\r\n      include: ['src/**/*.{vue,js,ts,jsx,tsx}'],\r\n      exclude: ['node_modules/**'],\r\n      useContext: false,\r\n      maxLength: 20,           // 默认最大20个字符\r\n      allowMixed: false,       // 不允许中英混合\r\n      allowPunctuation: false, // 不允许标点符号\r\n      ...options\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Extract Chinese text from file content\r\n   * @param filePath - Absolute path to the file\r\n   * @param content - File content\r\n   * @returns Array of extraction results\r\n   */\r\n  abstract extract(filePath: string, content: string): Promise<ExtractionResult[]> | ExtractionResult[]\r\n\r\n  /**\r\n   * Check if this extractor supports the given file\r\n   * @param filePath - Absolute path to the file\r\n   * @returns true if this extractor can handle the file\r\n   */\r\n  abstract supports(filePath: string): boolean\r\n\r\n  /**\r\n   * Check if text contains Chinese characters\r\n   * @param text - Text to check\r\n   * @returns true if text contains Chinese\r\n   */\r\n  protected hasChinese(text: string): boolean {\r\n    return /[\\u4e00-\\u9fa5]/.test(text)\r\n  }\r\n\r\n  /**\r\n   * Check if text should be extracted based on filtering rules\r\n   * @param text - Text to check\r\n   * @returns true if text should be extracted\r\n   */\r\n  protected shouldExtract(text: string): boolean {\r\n    // 必须包含中文\r\n    if (!this.hasChinese(text)) {\r\n      return false\r\n    }\r\n\r\n    const normalized = text.trim()\r\n\r\n    // 检查长度（只计算中文字符）\r\n    const chineseChars = normalized.match(/[\\u4e00-\\u9fa5]/g) || []\r\n    if (chineseChars.length > (this.options.maxLength || 20)) {\r\n      return false\r\n    }\r\n\r\n    // 检查中英混合\r\n    if (!this.options.allowMixed) {\r\n      const hasEnglish = /[a-zA-Z]/.test(normalized)\r\n      const hasChinese = /[\\u4e00-\\u9fa5]/.test(normalized)\r\n      if (hasEnglish && hasChinese) {\r\n        return false\r\n      }\r\n    }\r\n\r\n    // 检查标点符号（任何标点符号都不允许，除非明确允许）\r\n    if (!this.options.allowPunctuation) {\r\n      // 检查是否有任何标点符号（包括中文和英文标点）\r\n      const hasPunctuation = /[,\\.\\!?;:'\"~@#\\$%\\^&\\*\\(\\)\\[\\]{}|\\\\\\/\\+\\-=<>]/.test(normalized) ||\r\n        /[\\u3002\\uff0c\\u3001\\uff1f\\uff01\\uff1b\\uff1a\\u201c\\u201d\\u2018\\u2019\\uff08uff09\\u300a\\u300b\\uff1c\\uff5e\\uff5f\\u2026\\u2014\\u2022\\u25cf\\u25cb]/.test(normalized)\r\n\r\n      if (hasPunctuation) {\r\n        return false\r\n      }\r\n    }\r\n\r\n    return true\r\n  }\r\n\r\n  /**\r\n   * Remove whitespace and normalize text\r\n   * @param text - Text to normalize\r\n   * @returns Normalized text\r\n   */\r\n  protected normalizeText(text: string): string {\r\n    return text.trim().replace(/\\s+/g, ' ')\r\n  }\r\n}\r\n","/**\r\n * Vue Single File Component Extractor\r\n * Uses @vue/compiler-sfc to parse .vue files\r\n */\r\n\r\nimport { parse, SFCDescriptor } from '@vue/compiler-sfc'\r\nimport { BaseExtractor, ExtractionResult, ExtractorOptions } from './base.js'\r\n\r\nexport class VueExtractor extends BaseExtractor {\r\n  constructor(options: ExtractorOptions = {}) {\r\n    super(options)\r\n  }\r\n\r\n  supports(filePath: string): boolean {\r\n    return filePath.endsWith('.vue')\r\n  }\r\n\r\n  async extract(filePath: string, content: string): Promise<ExtractionResult[]> {\r\n    const results: ExtractionResult[] = []\r\n\r\n    try {\r\n      const { descriptor, errors } = parse(content)\r\n\r\n      if (errors && errors.length > 0) {\r\n        console.warn(`Failed to parse Vue file: ${filePath}`, errors)\r\n        return results\r\n      }\r\n\r\n      // Extract from template\r\n      if (descriptor.template) {\r\n        const templateTexts = this.extractFromTemplate(descriptor.template.ast)\r\n        results.push(...templateTexts)\r\n      }\r\n\r\n      // Extract from script\r\n      if (descriptor.script || descriptor.scriptSetup) {\r\n        const scriptContent = descriptor.script?.content || descriptor.scriptSetup?.content || ''\r\n        const scriptTexts = this.extractFromScript(scriptContent, 'script')\r\n        results.push(...scriptTexts)\r\n      }\r\n\r\n    } catch (error) {\r\n      console.error(`Error processing Vue file: ${filePath}`, error)\r\n    }\r\n\r\n    return results\r\n  }\r\n\r\n  /**\r\n   * Extract Chinese text from template AST\r\n   */\r\n  private extractFromTemplate(templateAst: any): ExtractionResult[] {\r\n    const texts: ExtractionResult[] = []\r\n\r\n    const traverse = (node: any) => {\r\n      if (!node) return\r\n\r\n      // Extract text nodes\r\n      if (node.type === 2 && this.shouldExtract(node.content)) {\r\n        // type 2 is TEXT type in Vue compiler\r\n        texts.push({\r\n          text: this.normalizeText(node.content),\r\n          line: node.loc?.start?.line || 0,\r\n          column: node.loc?.start?.column || 0,\r\n          type: 'template'\r\n        })\r\n      }\r\n\r\n      // Extract Chinese from attributes\r\n      if (node.type === 1 && node.props) {\r\n        // type 1 is ELEMENT type\r\n        node.props.forEach((prop: any) => {\r\n          if (prop.type === 6 && this.shouldExtract(prop.value?.content)) {\r\n            // type 6 is ATTRIBUTE type\r\n            texts.push({\r\n              text: prop.value.content,\r\n              line: prop.loc?.start?.line || 0,\r\n              column: prop.loc?.start?.column || 0,\r\n              type: 'template',\r\n              context: `attribute: ${prop.name}`\r\n            })\r\n          }\r\n        })\r\n      }\r\n\r\n      // Recursively traverse children\r\n      if (node.children) {\r\n        node.children.forEach(traverse)\r\n      }\r\n    }\r\n\r\n    traverse(templateAst)\r\n    return texts\r\n  }\r\n\r\n  /**\r\n   * Extract Chinese text from script content (using regex as fallback)\r\n   */\r\n  private extractFromScript(scriptContent: string, source: string): ExtractionResult[] {\r\n    const texts: ExtractionResult[] = []\r\n\r\n    if (!scriptContent) return texts\r\n\r\n    // Match string literals with Chinese\r\n    const patterns = [\r\n      /['\"`]([^'\"`]*[\\u4e00-\\u9fa5]+[^'\"`]*)['\"`]/g\r\n    ]\r\n\r\n    patterns.forEach(pattern => {\r\n      let match: RegExpExecArray | null\r\n      while ((match = pattern.exec(scriptContent)) !== null) {\r\n        const text = match[1]\r\n        if (this.shouldExtract(text) && text.trim().length > 0) {\r\n          texts.push({\r\n            text: this.normalizeText(text),\r\n            line: 0,\r\n            column: 0,\r\n            type: 'script'\r\n          })\r\n        }\r\n      }\r\n    })\r\n\r\n    return texts\r\n  }\r\n}\r\n\r\n// Export convenience function for backward compatibility\r\nexport function extractFromVueFile(filePath: string, content: string): ExtractionResult[] {\r\n  const extractor = new VueExtractor()\r\n  return extractor.extract(filePath, content) as any\r\n}\r\n","/**\r\n * JS/TS/JSX/TSX File Extractor\r\n * Supports Babel Parser (with OXC planned for future)\r\n */\r\n\r\nimport { parse, ParserOptions } from '@babel/parser'\r\nimport traverse from '@babel/traverse'\r\nimport { BaseExtractor, ExtractionResult, ExtractorOptions } from './base.js'\r\n\r\nexport interface JSExtractorOptions extends ExtractorOptions {\r\n  useBabel?: boolean\r\n  babelPlugins?: ParserOptions['plugins']\r\n}\r\n\r\nexport class JSExtractor extends BaseExtractor {\r\n  protected options: JSExtractorOptions\r\n\r\n  constructor(options: JSExtractorOptions = {}) {\r\n    super(options)\r\n    this.options = {\r\n      useBabel: true,\r\n      babelPlugins: [\r\n        'jsx',\r\n        'typescript'\r\n      ],\r\n      ...options\r\n    }\r\n  }\r\n\r\n  supports(filePath: string): boolean {\r\n    return /\\.(js|ts|jsx|tsx)$/.test(filePath)\r\n  }\r\n\r\n  async extract(filePath: string, content: string): Promise<ExtractionResult[]> {\r\n    if (this.options.useBabel) {\r\n      return this.extractWithBabel(content, filePath)\r\n    }\r\n    return this.extractWithRegex(content)\r\n  }\r\n\r\n  /**\r\n   * Extract Chinese text using Babel AST traversal\r\n   */\r\n  private extractWithBabel(content: string, filePath: string): ExtractionResult[] {\r\n    const results: ExtractionResult[] = []\r\n\r\n    try {\r\n      const ast = parse(content, {\r\n        sourceType: 'module',\r\n        plugins: this.options.babelPlugins\r\n      })\r\n\r\n      // Handle ESM default export\r\n      const traverseFn = (traverse as any).default || traverse\r\n\r\n      traverseFn(ast, {\r\n        // String literals\r\n        StringLiteral: (path: any) => {\r\n          const { node } = path\r\n          if (this.shouldExtract(node.value)) {\r\n            results.push({\r\n              text: node.value,\r\n              line: node.loc?.start?.line || 0,\r\n              column: node.loc?.start?.column || 0,\r\n              type: 'script'\r\n            })\r\n          }\r\n        },\r\n\r\n        // Template strings\r\n        TemplateElement: (path: any) => {\r\n          const { node } = path\r\n          if (this.shouldExtract(node.value.raw)) {\r\n            results.push({\r\n              text: this.normalizeText(node.value.raw),\r\n              line: node.loc?.start?.line || 0,\r\n              column: node.loc?.start?.column || 0,\r\n              type: 'script'\r\n            })\r\n          }\r\n        }\r\n      })\r\n\r\n    } catch (error) {\r\n      // AST parsing failed, fallback to regex\r\n      const errorMessage = error instanceof Error ? error.message : String(error)\r\n      if (process.env.VUE_I18N_VERBOSE === 'true') {\r\n        console.warn(`AST parsing failed for ${filePath}: ${errorMessage}`)\r\n      }\r\n      // Silently use regex as fallback\r\n      return this.extractWithRegex(content)\r\n    }\r\n\r\n    return results\r\n  }\r\n\r\n  /**\r\n   * Regex matching (fallback method)\r\n   */\r\n  private extractWithRegex(content: string): ExtractionResult[] {\r\n    const results: ExtractionResult[] = []\r\n\r\n    // Match Chinese in various scenarios\r\n    const patterns = [\r\n      // Single quoted strings\r\n      /'([^']*[\\u4e00-\\u9fa5]+[^']*)'/g,\r\n      // Double quoted strings\r\n      /\"([^\"]*[\\u4e00-\\u9fa5]+[^\"]*)\"/g,\r\n      // Template strings\r\n      /`([^`]*[\\u4e00-\\u9fa5]+[^`]*)`/g,\r\n      // JSX text\r\n      />([^<]*[\\u4e00-\\u9fa5]+[^<]*)</g\r\n    ]\r\n\r\n    patterns.forEach(pattern => {\r\n      let match: RegExpExecArray | null\r\n      while ((match = pattern.exec(content)) !== null) {\r\n        const text = match[1].trim()\r\n        if (this.shouldExtract(text) && text.length > 0) {\r\n          results.push({\r\n            text,\r\n            line: 0,\r\n            column: 0,\r\n            type: 'script'\r\n          })\r\n        }\r\n      }\r\n    })\r\n\r\n    return results\r\n  }\r\n}\r\n\r\n// Export convenience function for backward compatibility\r\nexport function extractFromJSFile(filePath: string, content: string): ExtractionResult[] {\r\n  const extractor = new JSExtractor()\r\n  return extractor.extract(filePath, content) as any\r\n}\r\n","/**\r\n * Extractors Module Entry Point\r\n */\r\n\r\nexport { BaseExtractor, type ExtractionResult, type ExtractorOptions } from './base.js'\r\nexport { VueExtractor, extractFromVueFile } from './vue-extractor.js'\r\nexport { JSExtractor, extractFromJSFile, type JSExtractorOptions } from './js-extractor.js'\r\n\r\n// Re-export convenience functions for backward compatibility\r\nexport async function extractChineseFromProject(options: any = {}) {\r\n  const { VueExtractor } = await import('./vue-extractor.js')\r\n  const { JSExtractor } = await import('./js-extractor.js')\r\n  const fg = (await import('fast-glob')).default\r\n  const fs = (await import('fs')).default\r\n  const path = (await import('path')).default\r\n\r\n  const {\r\n    include = ['src/**/*.{vue,js,ts,jsx,tsx}'],\r\n    exclude = ['node_modules/**'],\r\n    maxLength,\r\n    allowMixed,\r\n    allowPunctuation\r\n  } = options\r\n\r\n  // Scan all target files\r\n  const files = await fg.glob(include, { cwd: process.cwd(), ignore: exclude })\r\n\r\n  const results = {\r\n    uniqueTexts: [],\r\n    fileMap: {},\r\n    fileCount: 0,\r\n    totalOccurrences: 0\r\n  } as any\r\n\r\n  const textMap = new Map()\r\n\r\n  // 创建提取器时传递过滤选项\r\n  const extractorOptions = {\r\n    maxLength,\r\n    allowMixed,\r\n    allowPunctuation\r\n  }\r\n\r\n  const vueExtractor = new VueExtractor(extractorOptions)\r\n  const jsExtractor = new JSExtractor(extractorOptions)\r\n\r\n  for (const file of files) {\r\n    const filePath = path.resolve(process.cwd(), file)\r\n    const content = fs.readFileSync(filePath, 'utf-8')\r\n\r\n    let extracted: any[] = []\r\n\r\n    // Select extractor based on file type\r\n    if (file.endsWith('.vue')) {\r\n      extracted = await vueExtractor.extract(filePath, content)\r\n    } else if (/\\.(js|ts|jsx|tsx)$/.test(file)) {\r\n      extracted = await jsExtractor.extract(filePath, content)\r\n    }\r\n\r\n    if (extracted.length > 0) {\r\n      results.fileMap[file] = extracted\r\n      results.fileCount++\r\n      results.totalOccurrences += extracted.length\r\n\r\n      // Deduplicate and record file sources\r\n      extracted.forEach((item: any) => {\r\n        const key = item.text\r\n        if (!textMap.has(key)) {\r\n          textMap.set(key, {\r\n            text: key,\r\n            files: [{ file, line: item.line, column: item.column }]\r\n          })\r\n        } else {\r\n          const existing = textMap.get(key)\r\n          existing.files.push({ file, line: item.line, column: item.column })\r\n        }\r\n      })\r\n    }\r\n  }\r\n\r\n  results.uniqueTexts = Array.from(textMap.values())\r\n\r\n  return results\r\n}\r\n"],"mappings":"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","names":["traverse","parse","VueExtractor","JSExtractor"]}