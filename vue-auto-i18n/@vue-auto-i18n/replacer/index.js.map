{"version":3,"sources":["../src/index.ts"],"sourcesContent":["/**\r\n * @vue-auto-i18n/replacer\r\n * Code replacement tool for transforming Chinese text to $t() calls\r\n */\r\n\r\nimport { promises as fs } from 'fs'\r\nimport path from 'path'\r\nimport { parse } from '@vue/compiler-sfc'\r\nimport { parse as babelParse } from '@babel/parser'\r\nimport traverse from '@babel/traverse'\r\nimport generate from '@babel/generator'\r\nimport { loadLocale, generateKey } from '@vue-auto-i18n/core'\r\n\r\nexport interface ReplacerOptions {\r\n  localesDir?: string\r\n  include?: string[]\r\n  exclude?: string[]\r\n  createBackup?: boolean\r\n  dryRun?: boolean\r\n}\r\n\r\nexport interface ReplacerResult {\r\n  files: number\r\n  replacements: number\r\n  backups: number\r\n  dryRun: boolean\r\n}\r\n\r\n/**\r\n * Replace files with $t() calls\r\n */\r\nexport async function replaceFiles(\r\n  config: any,\r\n  options: ReplacerOptions = {}\r\n): Promise<ReplacerResult> {\r\n  const {\r\n    localesDir = config.localesDir || 'src/locales',\r\n    include = config.include || ['src/**/*.{vue,js,ts}'],\r\n    exclude = config.exclude || ['node_modules/**'],\r\n    createBackup = true,\r\n    dryRun = false\r\n  } = options\r\n\r\n  // Load language pack to get key mappings\r\n  const zhPack = await loadLocale('zh-CN', { localesDir })\r\n\r\n  if (Object.keys(zhPack).length === 0) {\r\n    throw new Error('No language pack found. Please run extract and translate first.')\r\n  }\r\n\r\n  // Build reverse map (text -> key)\r\n  const textToKeyMap: Record<string, string> = {}\r\n  for (const [key, value] of Object.entries(zhPack)) {\r\n    textToKeyMap[value as string] = key\r\n  }\r\n\r\n  // Scan files\r\n  const fg = await import('fast-glob')\r\n  const files = await fg.glob(include, { cwd: process.cwd(), ignore: exclude })\r\n\r\n  let totalFiles = 0\r\n  let totalReplacements = 0\r\n  let totalBackups = 0\r\n\r\n  for (const file of files) {\r\n    const filePath = path.resolve(process.cwd(), file)\r\n\r\n    try {\r\n      const content = await fs.readFile(filePath, 'utf-8')\r\n      let newContent = content\r\n      let replacements = 0\r\n\r\n      if (file.endsWith('.vue')) {\r\n        const result = replaceVueFile(content, textToKeyMap)\r\n        newContent = result.content\r\n        replacements = result.replacements\r\n      } else if (/\\.(js|ts|jsx|tsx)$/.test(file)) {\r\n        const result = replaceJSFile(content, textToKeyMap)\r\n        newContent = result.content\r\n        replacements = result.replacements\r\n      }\r\n\r\n      if (replacements > 0) {\r\n        totalFiles++\r\n        totalReplacements += replacements\r\n\r\n        if (!dryRun) {\r\n          // Create backup\r\n          if (createBackup) {\r\n            const backupPath = filePath + '.bak'\r\n            await fs.writeFile(backupPath, content, 'utf-8')\r\n            totalBackups++\r\n          }\r\n\r\n          // Write modified content\r\n          await fs.writeFile(filePath, newContent, 'utf-8')\r\n        }\r\n      }\r\n    } catch (error) {\r\n      const errorMessage = error instanceof Error ? error.message : String(error)\r\n      console.warn(`Warning: Failed to process ${file}:`, errorMessage)\r\n    }\r\n  }\r\n\r\n  return {\r\n    files: totalFiles,\r\n    replacements: totalReplacements,\r\n    backups: totalBackups,\r\n    dryRun\r\n  }\r\n}\r\n\r\n/**\r\n * Replace Chinese text in Vue file\r\n */\r\nfunction replaceVueFile(\r\n  content: string,\r\n  textToKeyMap: Record<string, string>\r\n): { content: string; replacements: number } {\r\n  let replacements = 0\r\n\r\n  try {\r\n    const { descriptor } = parse(content)\r\n\r\n    // Process template\r\n    if (descriptor.template) {\r\n      const template = descriptor.template.content\r\n      const newTemplate = replaceInTemplate(template, textToKeyMap)\r\n      if (newTemplate !== template) {\r\n        content = content.replace(template, newTemplate)\r\n        replacements += countReplacements(template, newTemplate)\r\n      }\r\n    }\r\n\r\n    // Process script\r\n    const scriptContent = descriptor.script?.content || descriptor.scriptSetup?.content || ''\r\n    if (scriptContent) {\r\n      const newScript = replaceInScript(scriptContent, textToKeyMap)\r\n      if (newScript !== scriptContent) {\r\n        content = content.replace(scriptContent, newScript)\r\n        replacements += countReplacements(scriptContent, newScript)\r\n      }\r\n    }\r\n  } catch (error) {\r\n    const errorMessage = error instanceof Error ? error.message : String(error)\r\n    console.warn('Failed to parse Vue file:', errorMessage)\r\n  }\r\n\r\n  return { content, replacements }\r\n}\r\n\r\n/**\r\n * Replace Chinese text in JS/TS file\r\n */\r\nfunction replaceJSFile(\r\n  content: string,\r\n  textToKeyMap: Record<string, string>\r\n): { content: string; replacements: number } {\r\n  const newContent = replaceInScript(content, textToKeyMap)\r\n  const replacements = countReplacements(content, newContent)\r\n\r\n  return { content: newContent, replacements }\r\n}\r\n\r\n/**\r\n * Replace in template section\r\n */\r\nfunction replaceInTemplate(\r\n  template: string,\r\n  textToKeyMap: Record<string, string>\r\n): string {\r\n  let result = template\r\n\r\n  for (const [text, key] of Object.entries(textToKeyMap)) {\r\n    // Escape special regex characters\r\n    const escapedText = text.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\r\n\r\n    // Replace in attributes: placeholder=\"用户名\" -> :placeholder=\"$t('key')\"\r\n    const attrRegex = new RegExp(`([a-zA-Z-]+)=[\"']${escapedText}[\"']`, 'g')\r\n    result = result.replace(attrRegex, (match, attrName) => {\r\n      return `:${attrName}=\"$t('${key}')\"`\r\n    })\r\n\r\n    // Replace in text content: >用户名< -> >{{ $t('key') }}<\r\n    const textRegex = new RegExp(`>([^<{]*)${escapedText}([^<}]*)<`, 'g')\r\n    result = result.replace(textRegex, (match, prefix, suffix) => {\r\n      if (prefix.includes('{') || suffix.includes('}')) return match\r\n      return `>{{ $t('${key}') }}<`\r\n    })\r\n  }\r\n\r\n  return result\r\n}\r\n\r\n/**\r\n * Replace in script section using Babel AST\r\n */\r\nfunction replaceInScript(\r\n  script: string,\r\n  textToKeyMap: Record<string, string>\r\n): string {\r\n  try {\r\n    const ast = babelParse(script, {\r\n      sourceType: 'module',\r\n      plugins: ['jsx', 'typescript', 'decorators-legacy']\r\n    })\r\n\r\n    let modified = false\r\n\r\n    traverse(ast, {\r\n      StringLiteral(path: any) {\r\n        const { node } = path\r\n        if (node.value in textToKeyMap) {\r\n          const key = textToKeyMap[node.value]\r\n          // Replace string with t() call\r\n          path.replaceWith({\r\n            type: 'CallExpression',\r\n            callee: {\r\n              type: 'Identifier',\r\n              name: 't'\r\n            },\r\n            arguments: [\r\n              {\r\n                type: 'StringLiteral',\r\n                value: key\r\n              }\r\n            ]\r\n          })\r\n          modified = true\r\n        }\r\n      }\r\n    })\r\n\r\n    if (modified) {\r\n      const output = generate(ast, {}, script)\r\n      return output.code\r\n    }\r\n  } catch (error) {\r\n    // Fallback to regex replacement\r\n    console.warn('AST parsing failed, using regex fallback')\r\n    return replaceInScriptRegex(script, textToKeyMap)\r\n  }\r\n\r\n  return script\r\n}\r\n\r\n/**\r\n * Regex fallback for script replacement\r\n */\r\nfunction replaceInScriptRegex(\r\n  script: string,\r\n  textToKeyMap: Record<string, string>\r\n): string {\r\n  let result = script\r\n\r\n  for (const [text, key] of Object.entries(textToKeyMap)) {\r\n    const escapedText = text.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\r\n    const regex = new RegExp(`['\"]${escapedText}['\"]`, 'g')\r\n    result = result.replace(regex, `t('${key}')`)\r\n  }\r\n\r\n  return result\r\n}\r\n\r\n/**\r\n * Count number of replacements made\r\n */\r\nfunction countReplacements(original: string, modified: string): number {\r\n  // Simple heuristic: count $t( or t( occurrences\r\n  const originalCount = (original.match(/\\$t\\(|t\\(/g) || []).length\r\n  const modifiedCount = (modified.match(/\\$t\\(|t\\(/g) || []).length\r\n  return Math.max(0, modifiedCount - originalCount)\r\n}\r\n"],"mappings":"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","names":["path"]}